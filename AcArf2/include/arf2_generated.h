// Source: Arf2.fbs
// Please conform to the License of FlatBuffers(Apache 2.0 License).


// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ARF2_H_
#define FLATBUFFERS_GENERATED_ARF2_H_
#include "flatbuffers/flatbuffers.h"


// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

struct WishChild;
struct WishChildBuilder;

struct WishGroup;
struct WishGroupBuilder;

struct Arf2Index;
struct Arf2IndexBuilder;

struct Arf2;
struct Arf2Builder;

struct WishChild FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WishChildBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_P = 4,
    VT_DT = 6,
    VT_ANODES = 8
  };
  uint8_t p() const {
    return GetField<uint8_t>(VT_P, 0);
  }
  uint32_t dt() const {
    return GetField<uint32_t>(VT_DT, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *anodes() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ANODES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_P, 1) &&
           VerifyField<uint32_t>(verifier, VT_DT, 4) &&
           VerifyOffset(verifier, VT_ANODES) &&
           verifier.VerifyVector(anodes()) &&
           verifier.EndTable();
  }
};

struct WishChildBuilder {
  typedef WishChild Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_p(uint8_t p) {
    fbb_.AddElement<uint8_t>(WishChild::VT_P, p, 0);
  }
  void add_dt(uint32_t dt) {
    fbb_.AddElement<uint32_t>(WishChild::VT_DT, dt, 0);
  }
  void add_anodes(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> anodes) {
    fbb_.AddOffset(WishChild::VT_ANODES, anodes);
  }
  explicit WishChildBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WishChild> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WishChild>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WishChild> CreateWishChild(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t p = 0,
    uint32_t dt = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> anodes = 0) {
  WishChildBuilder builder_(_fbb);
  builder_.add_anodes(anodes);
  builder_.add_dt(dt);
  builder_.add_p(p);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WishChild> CreateWishChildDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t p = 0,
    uint32_t dt = 0,
    const std::vector<uint32_t> *anodes = nullptr) {
  auto anodes__ = anodes ? _fbb.CreateVector<uint32_t>(*anodes) : 0;
  return CreateWishChild(
      _fbb,
      p,
      dt,
      anodes__);
}

struct WishGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WishGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INFO = 4,
    VT_NODES = 6,
    VT_CHILDS = 8
  };
  uint32_t info() const {
    return GetField<uint32_t>(VT_INFO, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *childs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<WishChild>> *>(VT_CHILDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INFO, 4) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           VerifyOffset(verifier, VT_CHILDS) &&
           verifier.VerifyVector(childs()) &&
           verifier.VerifyVectorOfTables(childs()) &&
           verifier.EndTable();
  }
};

struct WishGroupBuilder {
  typedef WishGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_info(uint32_t info) {
    fbb_.AddElement<uint32_t>(WishGroup::VT_INFO, info, 0);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> nodes) {
    fbb_.AddOffset(WishGroup::VT_NODES, nodes);
  }
  void add_childs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishChild>>> childs) {
    fbb_.AddOffset(WishGroup::VT_CHILDS, childs);
  }
  explicit WishGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WishGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WishGroup>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WishGroup> CreateWishGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishChild>>> childs = 0) {
  WishGroupBuilder builder_(_fbb);
  builder_.add_childs(childs);
  builder_.add_nodes(nodes);
  builder_.add_info(info);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WishGroup> CreateWishGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t info = 0,
    const std::vector<uint64_t> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<WishChild>> *childs = nullptr) {
  auto nodes__ = nodes ? _fbb.CreateVector<uint64_t>(*nodes) : 0;
  auto childs__ = childs ? _fbb.CreateVector<::flatbuffers::Offset<WishChild>>(*childs) : 0;
  return CreateWishGroup(
      _fbb,
      info,
      nodes__,
      childs__);
}

struct Arf2Index FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Arf2IndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDX = 4,
    VT_HIDX = 6
  };
  const ::flatbuffers::Vector<uint32_t> *widx() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_WIDX);
  }
  const ::flatbuffers::Vector<uint32_t> *hidx() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_HIDX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WIDX) &&
           verifier.VerifyVector(widx()) &&
           VerifyOffset(verifier, VT_HIDX) &&
           verifier.VerifyVector(hidx()) &&
           verifier.EndTable();
  }
};

struct Arf2IndexBuilder {
  typedef Arf2Index Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widx(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> widx) {
    fbb_.AddOffset(Arf2Index::VT_WIDX, widx);
  }
  void add_hidx(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> hidx) {
    fbb_.AddOffset(Arf2Index::VT_HIDX, hidx);
  }
  explicit Arf2IndexBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Arf2Index> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Arf2Index>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Arf2Index> CreateArf2Index(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> widx = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> hidx = 0) {
  Arf2IndexBuilder builder_(_fbb);
  builder_.add_hidx(hidx);
  builder_.add_widx(widx);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Arf2Index> CreateArf2IndexDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *widx = nullptr,
    const std::vector<uint32_t> *hidx = nullptr) {
  auto widx__ = widx ? _fbb.CreateVector<uint32_t>(*widx) : 0;
  auto hidx__ = hidx ? _fbb.CreateVector<uint32_t>(*hidx) : 0;
  return CreateArf2Index(
      _fbb,
      widx__,
      hidx__);
}

struct Arf2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Arf2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INIT_MS = 4,
    VT_END_MS = 6,
    VT_TOTAL_HINTS = 8,
    VT_WGO_REQUIRED = 10,
    VT_HGO_REQUIRED = 12,
    VT_WISH = 14,
    VT_HINT = 16,
    VT_SPECIAL_HINT = 18,
    VT_DTS_LAYER1 = 20,
    VT_DTS_LAYER2 = 22,
    VT_INDEX = 24
  };
  uint32_t init_ms() const {
    return GetField<uint32_t>(VT_INIT_MS, 0);
  }
  uint32_t end_ms() const {
    return GetField<uint32_t>(VT_END_MS, 0);
  }
  uint32_t total_hints() const {
    return GetField<uint32_t>(VT_TOTAL_HINTS, 0);
  }
  uint32_t wgo_required() const {
    return GetField<uint32_t>(VT_WGO_REQUIRED, 0);
  }
  uint32_t hgo_required() const {
    return GetField<uint32_t>(VT_HGO_REQUIRED, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *wish() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>> *>(VT_WISH);
  }
  const ::flatbuffers::Vector<uint64_t> *hint() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_HINT);
  }
  uint32_t special_hint() const {
    return GetField<uint32_t>(VT_SPECIAL_HINT, 0);
  }
  const ::flatbuffers::Vector<uint64_t> *dts_layer1() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER1);
  }
  const ::flatbuffers::Vector<uint64_t> *dts_layer2() const {
    return GetPointer<const ::flatbuffers::Vector<uint64_t> *>(VT_DTS_LAYER2);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *index() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>> *>(VT_INDEX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_INIT_MS, 4) &&
           VerifyField<uint32_t>(verifier, VT_END_MS, 4) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL_HINTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_WGO_REQUIRED, 4) &&
           VerifyField<uint32_t>(verifier, VT_HGO_REQUIRED, 4) &&
           VerifyOffset(verifier, VT_WISH) &&
           verifier.VerifyVector(wish()) &&
           verifier.VerifyVectorOfTables(wish()) &&
           VerifyOffset(verifier, VT_HINT) &&
           verifier.VerifyVector(hint()) &&
           VerifyField<uint32_t>(verifier, VT_SPECIAL_HINT, 4) &&
           VerifyOffset(verifier, VT_DTS_LAYER1) &&
           verifier.VerifyVector(dts_layer1()) &&
           VerifyOffset(verifier, VT_DTS_LAYER2) &&
           verifier.VerifyVector(dts_layer2()) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           verifier.VerifyVectorOfTables(index()) &&
           verifier.EndTable();
  }
};

struct Arf2Builder {
  typedef Arf2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_init_ms(uint32_t init_ms) {
    fbb_.AddElement<uint32_t>(Arf2::VT_INIT_MS, init_ms, 0);
  }
  void add_end_ms(uint32_t end_ms) {
    fbb_.AddElement<uint32_t>(Arf2::VT_END_MS, end_ms, 0);
  }
  void add_total_hints(uint32_t total_hints) {
    fbb_.AddElement<uint32_t>(Arf2::VT_TOTAL_HINTS, total_hints, 0);
  }
  void add_wgo_required(uint32_t wgo_required) {
    fbb_.AddElement<uint32_t>(Arf2::VT_WGO_REQUIRED, wgo_required, 0);
  }
  void add_hgo_required(uint32_t hgo_required) {
    fbb_.AddElement<uint32_t>(Arf2::VT_HGO_REQUIRED, hgo_required, 0);
  }
  void add_wish(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>>> wish) {
    fbb_.AddOffset(Arf2::VT_WISH, wish);
  }
  void add_hint(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> hint) {
    fbb_.AddOffset(Arf2::VT_HINT, hint);
  }
  void add_special_hint(uint32_t special_hint) {
    fbb_.AddElement<uint32_t>(Arf2::VT_SPECIAL_HINT, special_hint, 0);
  }
  void add_dts_layer1(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer1) {
    fbb_.AddOffset(Arf2::VT_DTS_LAYER1, dts_layer1);
  }
  void add_dts_layer2(::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer2) {
    fbb_.AddOffset(Arf2::VT_DTS_LAYER2, dts_layer2);
  }
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>>> index) {
    fbb_.AddOffset(Arf2::VT_INDEX, index);
  }
  explicit Arf2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Arf2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Arf2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Arf2> CreateArf2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t init_ms = 0,
    uint32_t end_ms = 0,
    uint32_t total_hints = 0,
    uint32_t wgo_required = 0,
    uint32_t hgo_required = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<WishGroup>>> wish = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> hint = 0,
    uint32_t special_hint = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer1 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint64_t>> dts_layer2 = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Arf2Index>>> index = 0) {
  Arf2Builder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_dts_layer2(dts_layer2);
  builder_.add_dts_layer1(dts_layer1);
  builder_.add_special_hint(special_hint);
  builder_.add_hint(hint);
  builder_.add_wish(wish);
  builder_.add_hgo_required(hgo_required);
  builder_.add_wgo_required(wgo_required);
  builder_.add_total_hints(total_hints);
  builder_.add_end_ms(end_ms);
  builder_.add_init_ms(init_ms);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Arf2> CreateArf2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t init_ms = 0,
    uint32_t end_ms = 0,
    uint32_t total_hints = 0,
    uint32_t wgo_required = 0,
    uint32_t hgo_required = 0,
    const std::vector<::flatbuffers::Offset<WishGroup>> *wish = nullptr,
    const std::vector<uint64_t> *hint = nullptr,
    uint32_t special_hint = 0,
    const std::vector<uint64_t> *dts_layer1 = nullptr,
    const std::vector<uint64_t> *dts_layer2 = nullptr,
    const std::vector<::flatbuffers::Offset<Arf2Index>> *index = nullptr) {
  auto wish__ = wish ? _fbb.CreateVector<::flatbuffers::Offset<WishGroup>>(*wish) : 0;
  auto hint__ = hint ? _fbb.CreateVector<uint64_t>(*hint) : 0;
  auto dts_layer1__ = dts_layer1 ? _fbb.CreateVector<uint64_t>(*dts_layer1) : 0;
  auto dts_layer2__ = dts_layer2 ? _fbb.CreateVector<uint64_t>(*dts_layer2) : 0;
  auto index__ = index ? _fbb.CreateVector<::flatbuffers::Offset<Arf2Index>>(*index) : 0;
  return CreateArf2(
      _fbb,
      init_ms,
      end_ms,
      total_hints,
      wgo_required,
      hgo_required,
      wish__,
      hint__,
      special_hint,
      dts_layer1__,
      dts_layer2__,
      index__);
}

inline const Arf2 *GetArf2(const void *buf) {
  return ::flatbuffers::GetRoot<Arf2>(buf);
}

inline const Arf2 *GetSizePrefixedArf2(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Arf2>(buf);
}

inline bool VerifyArf2Buffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Arf2>(nullptr);
}

inline bool VerifySizePrefixedArf2Buffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Arf2>(nullptr);
}

inline void FinishArf2Buffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Arf2> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedArf2Buffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Arf2> root) {
  fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_ARF2_H_
